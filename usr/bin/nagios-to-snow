#!/usr/bin/env perl

=head1 NAME

nagios-to-snow - integrates Nagios and ServiceNow Incidents

=head1 SYNOPSIS

B<nagios-to-snow> --type I<PROBLEM|ACKNOWLEDGE|RECOVERY> < I<STDIN>

=head1 DESCRIPTION

nagios-to-snow creates and manages incidents in Service Now based on inputs
from Nagios.  This generally consists of three types of actions: PROBLEM
(creates a ticket), ACKNOWLEDGE (updates the ticket), and RECOVERY (closes the
ticket).

Logs of open tickets are stored in a central directory (defined in a central
configuration file).

=cut

##############################################################################
### Configuration ############################################################
##############################################################################

use lib '/home/tskirvin/rpm/cms-monitor/lib';
our $CONFIG_FILE = '/home/tskirvin/rpm/cms-monitor/etc/snow/config.yaml';

our $CONFIG = FNAL::SNOW->load_yaml ($CONFIG_FILE);

$CONFIG->{ack}->{author} ||= `whoami`;

our $OMD_SITE = $ENV{'OMD_SITE'} || 'unset';
our $DEBUG = 0;

use vars qw/$CI $TYPE/;

##############################################################################
### Declarations #############################################################
##############################################################################

use strict;
use warnings;

use Class::Struct;
use Getopt::Long;
use MIME::Lite;
use Pod::Usage;
use Sys::Hostname;

use ServiceNow;
use ServiceNow::Configuration;

use FNAL::SNOW;
use FNAL::NagiosIncident;

$|++;
our @ARGS_ORIG = @ARGV;

##############################################################################
### Subroutines ##############################################################
##############################################################################

### error_mail (SUBJECT, BODY, ERROR)
# Send an error email, based on $CONFIG->{errormail} and the passed in values.
sub error_mail {
    ## Gather variables for function
    my ($subject, $body, $errorText) = @_;

    my @debug;
    push @debug, "=====[ DEBUG ]=====";
    push @debug, "command line:\n  $0 @ARGS_ORIG\n\n";
    foreach my $field (qw/ticket nagios/) {
        push @debug, "$field:";
        foreach my $key (sort keys %{$CONFIG->{$field}}) {
           my $value = $CONFIG->{$field}->{$key};
           push @debug, sprintf ("  %25s: %s", $key,
               ($CONFIG->{$field}->{$key} || ''));
        }
        push @debug, '';
    }
    push @debug, "=====[ /DEBUG ]=====";

    my @text;
    push @text, "=====[ TEXT ]=====";
    foreach (split "\n", $body) {
        chomp;
        push @text, $_;
    }
    push @text, "=====[ /TEXT ]=====";

    my $prefix = $CONFIG->{errormail}->{subject_prefix};

    my $msg = MIME::Lite->new (
        Subject => "[$prefix] $subject",
        From    => $CONFIG->{errormail}->{from},
        To      => $CONFIG->{errormail}->{to},
        Data    => join("\n", $errorText, '', @text, '', @debug, ''),
    );

    if ($DEBUG) {
        $msg->print (\*STDOUT);
    } else {
        $msg->send;
        print $errorText, "\n";
    }

    exit -1;
}

### error_usage (ERROR)
# Exit out with pod2usage.
sub error_usage {
    my ($error) = @_;
    pod2usage (-exit_status => 2, -verbose => 1);
}

### debug (MSG)
# Print a debugging message if $DEBUG is set.
sub debug { if ($DEBUG) { warn "@_\n" } }

### make_notes (MSG)
# Generate a formatted error message for text fields in SN.  
sub make_notes {
    my @return;
    while (@_) { push @return, sprintf ("<b>%s</b>: %s", shift, shift) }
    return "[code]<br />" . join('<br />', @return) . "[/code]"
}

##############################################################################
### main () ##################################################################
##############################################################################



my $parser = Getopt::Long::Parser->new();
my $result = $parser->getoptions (

    ## Required Parameters
    't|type=s'    => \$TYPE,
    'ci|ciname=s' => \$CI,

    ## Optional Parameters
    'd|debug'   => \$DEBUG,
    'omdsite=s' => \$OMD_SITE,

    'filepath=s' => sub { $CONFIG->{cachedir} = $_[1] },

    ## Service Now Parameters
    'snURL=s'       => sub { set_config ('servicenow', 'url',      @_ ) },
    'snPassword=s'  => sub { set_config ('servicenow', 'password', @_ ) },
    'snUsername=s'  => sub { set_config ('servicenow', 'username', @_ ) },

    ## Incident fields that don't quite match the field name
    'caller=s'   => sub { set_ticket ('caller_id',         $_[1]) },
    'incident=s' => sub { set_ticket ('incident_number',   $_[1]) },
    'page=i'     => sub { set_ticket ('u_page_primary',    $_[1]) },
    'subject=s'  => sub { set_ticket ('short_description', $_[1]) },

    ## Incident fields that *do* match the field name
    'category=s'             => sub { set_ticket (@_) },
    'impact=i'               => sub { set_ticket (@_) },
    'lastserviceproblemid=s' => sub { set_ticket (@_) },
    'servicename=s'          => sub { set_ticket (@_) },
    'serviceproblemid=s'     => sub { set_ticket (@_) },
    'state=s'                => sub { set_ticket (@_) },
    'urgency=i'              => sub { set_ticket (@_) },
    'assignment_group=s'     => sub { set_ticket (@_) },

    ## Error email fields
    'emailFrom=s'            => sub { set_config ('errormail', 'from', @_ ) },
    'emailErrorList=s'       => sub { set_config ('errormail', 'to',   @_ ) },

    ## Nagios acknowledgement information
    'ackauthor:s'            => sub { set_ack ('author', $_[1] ) },
    'ackcomment:s'           => sub { set_ack ('comment', $_[1] ) },

    'man'      => sub { pod2usage (-verbose => 2, -noperldoc => 1) },
    'h|help'   => sub { pod2usage (-verbose => 1) }) || error_usage ();

unless ($TYPE) { error_usage ("no '--type' offered") }
unless ($CI)   { error_usage ("no '--ciname' offered") }

$FNAL::NagiosIncident::BASEDIR = $CONFIG->{cachedir};

debug "Getting text on STDIN";
my $description = join ("\n", <>);

debug "Connecting to ServiceNow at $CONFIG->{servicenow}->{url}";
my $SN = SNOW::connect_to_sn ($CONFIG);

my ($svcName, $url);

if ($CONFIG->{ticket}->{servicename} eq 'host') {
    $svcName = $CI;
    $url     = FNAL::SNOW::nagios_url ($CI)
} else {
    my $sname = $CONFIG->{ticket}->{servicename};
    my $id = $CONFIG->{ticket}->{serviceproblemid}
        || $CONFIG->{ticket}->{lastserviceproblemid}
        || 0;

    $svcName = join (':', $CI, $sname, $id);
    $url     = FNAL::SNOW::nagios_url ($CI, $sname);
}


if   (lc $TYPE eq 'problem') {
    set_ticket ('description', $description);
    set_ticket ('cmdb_ci',     $svcName);

    debug "Do we already have an incident for '$svcName'?";
    if ( my $inc = SNOW::Incident->read ($svcName) ) {
        my $filename = $inc->filename;
        debug "file $filename already exists";
        error_mail ("PROBLEM $svcName", $description,
            "file $filename already exists; will not cut another ticket");
    }

    debug "Creating incident for $svcName";
    my $incident_number = $SN->createIncident ( $CONFIG->{ticket} );
    unless ($incident_number) {
        error_mail ("PROBLEM $svcName", $description, "ticket was not created")
    }

    my $incident = SNOW::Incident->create ($svcName);
    $incident->incident ($incident_number);
    debug "Writing $incident_number information to " . $incident->filename;
    $incident->write;

    $SN->appendJournal( $incident_number, 'work_notes',
        make_notes (
            'URL' => "<a href='$url' target='_blank'>$url</a>", 
            'Reporting Nagios Site' => $OMD_SITE
        )
    );
}


elsif (lc $TYPE eq 'recovery') {
    my $prefix = "RECOVERY $svcName";

    debug "Opening existing ticket for $svcName";
    my $incident = SNOW::Incident->read ($svcName);
    unless ($incident) {
        error_mail($prefix, $description, "could not open incident '$svcName'");
    }

    if (my $fileIncNumber = $incident->incident) {
        debug "Updating $fileIncNumber on ServiceNow";
        my $text = "The host/service has been restored";
        $SN->updateIncident($fileIncNumber, {
            'closed_by'      => $CONFIG->{servicenow}->{username},
            'close_code'     => 'Other (must describe below)',
            'close_notes'    => $text,
            'incident_state' => '6',
        }) or error_mail ($prefix, $description, "could not update incident");
        $SN->appendJournal ($fileIncNumber, 'work_notes',
            make_notes ( 'Automated Message', 'Service has recovered' )
        ) or error_mail ($prefix, $description, "could not update journal");

        debug "Removing SNOW::Incident file for $fileIncNumber";
        $incident->unlink or error_mail ($prefix, $description,
            "could not unlink inc file $svcName: $!");
    } else {
        die "no incident number for $svcName in file $incident->file\n";
    }
}

elsif (lc $TYPE =~ /^ack/i) {
    my $prefix = "ACK $svcName";

    debug "Opening existing ticket for $svcName";
    my $incident = SNOW::Incident->read ($svcName);
    unless ($incident) {
        error_mail($prefix, $description,
            "could not open incident '$svcName'");
    }

    my $fileIncNumber = $incident->incident;
    if ($fileIncNumber eq "") {
        error_mail ($prefix, $description,
            "no INC in $svcName (" .  $incident->file .")" );
    }

    my $fileAck = $incident->ack || 'unknown';
    if ($fileAck eq 'unknown') {
        debug "$fileIncNumber: acknowledging";
        $SN->updateIncident ($fileIncNumber, {
            'assigned_to'    => $CONFIG->{ack}->{author},
            'incident_state' => '2',
        }) or error_mail ($prefix, $description, "could not update incident");
        $SN->appendJournal ($fileIncNumber, 'comments', make_notes (
            'Acked in Nagios by', $CONFIG->{ack}->{author}  || '',
            'Nagios comment',     $CONFIG->{ack}->{comment} || ''
        )) or error_mail ($prefix, $description, "could not update journal");

        debug "writing SNOW::Incident";
        $incident->ack ('yes');
        $incident->write;
     } else {
         print "incident $svcName already acknowledged\n";
         exit 0;
     }
}

else { error_usage ("unknown type: $TYPE") }

exit 0;

##############################################################################
### Final Documentation ######################################################
##############################################################################

=head1 OPTIONS

=over 4

=item B<-page>

Values <0|1>: Execute paging operation within ServiceNow upon ticket creation.

=item B<-urgency>

Values [1-5]: ServiceNow urgency value

=item B<-impact>

Values [1-5]: ServiceNow impact value

=item B<-ciname>

String: Hostname of the machine, will be used within the CI field of ServiceNow

=item B<-type>

Values [PROBLEM|RECOVERY|ACKNOWLEDGEMENT]

=item B<-state>

Values [UP|DOWN]: Nagios state for specified asset

=item B<-subject>

String: ServiceNow subject field used in the creation of a new ticket.

=item B<-incident>

String: ServiceNow incident number

=item B<-ackauthor>

String: Value used to assign ticket ownership within ServiceNow

=item B<-ackcomment>

String: Value inserted into journal entry of ServiceNow while
acknowledging a ticket

=item B<-categorization>

String: ServiceNow u_categorization field

=item B<-assignmentGroup>

String: ServiceNow group which should be assigned the newly created ticket

=item B<-caller>

String: ServiceNow caller_id field

=item B<-filepath>

String: Location where Nagios incident files should be stored

=item B<-snURL>

String: ServiceNow URL

=item B<-snUsername>

String: ServiceNow Username

=item B<-snPassword>

String: ServiceNow Password

=item B<--type> F<TYPE>

What kind of update is this?  Must be one of the following: PROBLEM,
ACKNOWLEDGEMENT, or RECOVERY.  Required.

=item B<--help>

Prints out basic full help documentation and exits.

=item B<--man>

Prints out the full help documentation and exits.

=back

=head1 DATA FILES

=head1 SCHEMA

=over 4

=item Host Alerts

=item Service Alerts

=back 4

=head1 EXAMPLES

=over 2

=item PROBLEM

    echo -n "(sample)\n<==End of alert==>" | \
        nagios-to-snow --type=PROBLEM \
        --ciname=d0www  --state=DOWN \
        --subject="Nagios Host Alert: Problem with d0www"

=item ACKNOWLEDGEMENT

    echo -n "(sample)\n<==End of alert==>" | \
        nagios-to-snow --type=ACKNOWLEDGEMENT \
        --ciname=d0www --state=DOWN \
        --subject="Nagios Host Alert: Problem with d0www" \
        --ackauthor="`whoami`" \
        --ackcomment="This is a sample acknowledgment"

=item RECOVERY

    echo -n "(sample)\n<==End of alert==>" | \
        nagios-to-snow --type=RECOVERY \
        --ciname=d0www --state=UP

=back

=head1 AUTHOR

Tyler Parsons <tyler.parsons-fermilab@dynamicpulse.com>

Tim Skirvin <tskirvin@fnal.gov>

=cut
